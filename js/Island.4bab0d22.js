"use strict";(self["webpackChunkcreation_gallery"]=self["webpackChunkcreation_gallery"]||[]).push([[300],{89174:function(t,e,r){r.r(e),r.d(e,{default:function(){return g}});var n=r(58258),o=r(69694),i=r(75030),a=r(24953);r(53297),r(75898),r(66653),r(91242),r(26057),r(55624),r(39820),r(83202),r(77425),r(62228);const s=new WeakMap;class l extends i.aHM{constructor(t){super(t),this.decoderPath="",this.decoderConfig={},this.decoderBinary=null,this.decoderPending=null,this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.defaultAttributeIDs={position:"POSITION",normal:"NORMAL",color:"COLOR",uv:"TEX_COORD"},this.defaultAttributeTypes={position:"Float32Array",normal:"Float32Array",color:"Float32Array",uv:"Float32Array"}}setDecoderPath(t){return this.decoderPath=t,this}setDecoderConfig(t){return this.decoderConfig=t,this}setWorkerLimit(t){return this.workerLimit=t,this}load(t,e,r,n){const o=new i.Y9S(this.manager);o.setPath(this.path),o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(t,(t=>{this.decodeDracoFile(t,e).catch(n)}),r,n)}decodeDracoFile(t,e,r,n){const o={attributeIDs:r||this.defaultAttributeIDs,attributeTypes:n||this.defaultAttributeTypes,useUniqueIDs:!!r};return this.decodeGeometry(t,o).then(e)}decodeGeometry(t,e){const r=JSON.stringify(e);if(s.has(t)){const e=s.get(t);if(e.key===r)return e.promise;if(0===t.byteLength)throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")}let n;const o=this.workerNextTaskID++,i=t.byteLength,a=this._getWorker(o,i).then((r=>(n=r,new Promise(((r,i)=>{n._callbacks[o]={resolve:r,reject:i},n.postMessage({type:"decode",id:o,taskConfig:e,buffer:t},[t])}))))).then((t=>this._createGeometry(t.geometry)));return a.catch((()=>!0)).then((()=>{n&&o&&this._releaseTask(n,o)})),s.set(t,{key:r,promise:a}),a}_createGeometry(t){const e=new i.LoY;t.index&&e.setIndex(new i.THS(t.index.array,1));for(let r=0;r<t.attributes.length;r++){const n=t.attributes[r],o=n.name,a=n.array,s=n.itemSize;e.setAttribute(o,new i.THS(a,s))}return e}_loadLibrary(t,e){const r=new i.Y9S(this.manager);return r.setPath(this.decoderPath),r.setResponseType(e),r.setWithCredentials(this.withCredentials),new Promise(((e,n)=>{r.load(t,e,void 0,n)}))}preload(){return this._initDecoder(),this}_initDecoder(){if(this.decoderPending)return this.decoderPending;const t="object"!==typeof WebAssembly||"js"===this.decoderConfig.type,e=[];return t?e.push(this._loadLibrary("draco_decoder.js","text")):(e.push(this._loadLibrary("draco_wasm_wrapper.js","text")),e.push(this._loadLibrary("draco_decoder.wasm","arraybuffer"))),this.decoderPending=Promise.all(e).then((e=>{const r=e[0];t||(this.decoderConfig.wasmBinary=e[1]);const n=c.toString(),o=["/* draco decoder */",r,"","/* worker */",n.substring(n.indexOf("{")+1,n.lastIndexOf("}"))].join("\n");this.workerSourceURL=URL.createObjectURL(new Blob([o]))})),this.decoderPending}_getWorker(t,e){return this._initDecoder().then((()=>{if(this.workerPool.length<this.workerLimit){const t=new Worker(this.workerSourceURL);t._callbacks={},t._taskCosts={},t._taskLoad=0,t.postMessage({type:"init",decoderConfig:this.decoderConfig}),t.onmessage=function(e){const r=e.data;switch(r.type){case"decode":t._callbacks[r.id].resolve(r);break;case"error":t._callbacks[r.id].reject(r);break;default:console.error('THREE.DRACOLoader: Unexpected message, "'+r.type+'"')}},this.workerPool.push(t)}else this.workerPool.sort((function(t,e){return t._taskLoad>e._taskLoad?-1:1}));const r=this.workerPool[this.workerPool.length-1];return r._taskCosts[t]=e,r._taskLoad+=e,r}))}_releaseTask(t,e){t._taskLoad-=t._taskCosts[e],delete t._callbacks[e],delete t._taskCosts[e]}debug(){console.log("Task load: ",this.workerPool.map((t=>t._taskLoad)))}dispose(){for(let t=0;t<this.workerPool.length;++t)this.workerPool[t].terminate();return this.workerPool.length=0,""!==this.workerSourceURL&&URL.revokeObjectURL(this.workerSourceURL),this}}function c(){let t,e;function r(t,e,r,i){const a=i.attributeIDs,s=i.attributeTypes;let l,c;const d=e.GetEncodedGeometryType(r);if(d===t.TRIANGULAR_MESH)l=new t.Mesh,c=e.DecodeBufferToMesh(r,l);else{if(d!==t.POINT_CLOUD)throw new Error("THREE.DRACOLoader: Unexpected geometry type.");l=new t.PointCloud,c=e.DecodeBufferToPointCloud(r,l)}if(!c.ok()||0===l.ptr)throw new Error("THREE.DRACOLoader: Decoding failed: "+c.error_msg());const u={index:null,attributes:[]};for(const n in a){const r=self[s[n]];let c,d;if(i.useUniqueIDs)d=a[n],c=e.GetAttributeByUniqueId(l,d);else{if(d=e.GetAttributeId(l,t[a[n]]),-1===d)continue;c=e.GetAttribute(l,d)}u.attributes.push(o(t,e,l,n,r,c))}return d===t.TRIANGULAR_MESH&&(u.index=n(t,e,l)),t.destroy(l),u}function n(t,e,r){const n=r.num_faces(),o=3*n,i=4*o,a=t._malloc(i);e.GetTrianglesUInt32Array(r,i,a);const s=new Uint32Array(t.HEAPF32.buffer,a,o).slice();return t._free(a),{array:s,itemSize:1}}function o(t,e,r,n,o,a){const s=a.num_components(),l=r.num_points(),c=l*s,d=c*o.BYTES_PER_ELEMENT,u=i(t,o),h=t._malloc(d);e.GetAttributeDataArrayForAllPoints(r,a,u,d,h);const m=new o(t.HEAPF32.buffer,h,c).slice();return t._free(h),{name:n,array:m,itemSize:s}}function i(t,e){switch(e){case Float32Array:return t.DT_FLOAT32;case Int8Array:return t.DT_INT8;case Int16Array:return t.DT_INT16;case Int32Array:return t.DT_INT32;case Uint8Array:return t.DT_UINT8;case Uint16Array:return t.DT_UINT16;case Uint32Array:return t.DT_UINT32}}onmessage=function(n){const o=n.data;switch(o.type){case"init":t=o.decoderConfig,e=new Promise((function(e){t.onModuleLoaded=function(t){e({draco:t})},DracoDecoderModule(t)}));break;case"decode":const n=o.buffer,i=o.taskConfig;e.then((t=>{const e=t.draco,a=new e.Decoder,s=new e.DecoderBuffer;s.Init(new Int8Array(n),n.byteLength);try{const t=r(e,a,s,i),n=t.attributes.map((t=>t.array.buffer));t.index&&n.push(t.index.array.buffer),self.postMessage({type:"decode",id:o.id,geometry:t},n)}catch(l){console.error(l),self.postMessage({type:"error",id:o.id,error:l.message})}finally{e.destroy(s),e.destroy(a)}}));break}}}class d extends i.BRH{constructor(t){super(t),this.type=i.ix0}parse(t){const e=-1,r=1,n=2,o=3,a=4,s=function(t,i){switch(t){case r:console.error("THREE.RGBELoader Read Error: "+(i||""));break;case n:console.error("THREE.RGBELoader Write Error: "+(i||""));break;case o:console.error("THREE.RGBELoader Bad File Format: "+(i||""));break;default:case a:console.error("THREE.RGBELoader: Error: "+(i||""))}return e},l=1,c=2,d=4,u="\n",h=function(t,e,r){const n=128;e=e||1024;let o=t.pos,i=-1,a=0,s="",l=String.fromCharCode.apply(null,new Uint16Array(t.subarray(o,o+n)));while(0>(i=l.indexOf(u))&&a<e&&o<t.byteLength)s+=l,a+=l.length,o+=n,l+=String.fromCharCode.apply(null,new Uint16Array(t.subarray(o,o+n)));return-1<i&&(!1!==r&&(t.pos+=a+i+1),s+l.slice(0,i))},m=function(t){const e=/^#\?(\S+)/,n=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,i=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,a=/^\s*FORMAT=(\S+)\s*$/,u=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,m={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};let f,p;if(t.pos>=t.byteLength||!(f=h(t)))return s(r,"no header found");if(!(p=f.match(e)))return s(o,"bad initial token");m.valid|=l,m.programtype=p[1],m.string+=f+"\n";while(1){if(f=h(t),!1===f)break;if(m.string+=f+"\n","#"!==f.charAt(0)){if((p=f.match(n))&&(m.gamma=parseFloat(p[1])),(p=f.match(i))&&(m.exposure=parseFloat(p[1])),(p=f.match(a))&&(m.valid|=c,m.format=p[1]),(p=f.match(u))&&(m.valid|=d,m.height=parseInt(p[1],10),m.width=parseInt(p[2],10)),m.valid&c&&m.valid&d)break}else m.comments+=f+"\n"}return m.valid&c?m.valid&d?m:s(o,"missing image size specifier"):s(o,"missing format specifier")},f=function(t,e,n){const i=e;if(i<8||i>32767||2!==t[0]||2!==t[1]||128&t[2])return new Uint8Array(t);if(i!==(t[2]<<8|t[3]))return s(o,"wrong scanline width");const l=new Uint8Array(4*e*n);if(!l.length)return s(a,"unable to allocate buffer space");let c=0,d=0;const u=4*i,h=new Uint8Array(4),m=new Uint8Array(u);let f=n;while(f>0&&d<t.byteLength){if(d+4>t.byteLength)return s(r);if(h[0]=t[d++],h[1]=t[d++],h[2]=t[d++],h[3]=t[d++],2!=h[0]||2!=h[1]||(h[2]<<8|h[3])!=i)return s(o,"bad rgbe scanline format");let e,n=0;while(n<u&&d<t.byteLength){e=t[d++];const r=e>128;if(r&&(e-=128),0===e||n+e>u)return s(o,"bad scanline data");if(r){const r=t[d++];for(let t=0;t<e;t++)m[n++]=r}else m.set(t.subarray(d,d+e),n),n+=e,d+=e}const a=i;for(let t=0;t<a;t++){let e=0;l[c]=m[t+e],e+=i,l[c+1]=m[t+e],e+=i,l[c+2]=m[t+e],e+=i,l[c+3]=m[t+e],c+=4}f--}return l},p=function(t,e,r,n){const o=t[e+3],i=Math.pow(2,o-128)/255;r[n+0]=t[e+0]*i,r[n+1]=t[e+1]*i,r[n+2]=t[e+2]*i,r[n+3]=1},w=function(t,e,r,n){const o=t[e+3],a=Math.pow(2,o-128)/255;r[n+0]=i.GxU.toHalfFloat(Math.min(t[e+0]*a,65504)),r[n+1]=i.GxU.toHalfFloat(Math.min(t[e+1]*a,65504)),r[n+2]=i.GxU.toHalfFloat(Math.min(t[e+2]*a,65504)),r[n+3]=i.GxU.toHalfFloat(1)},g=new Uint8Array(t);g.pos=0;const y=m(g);if(e!==y){const t=y.width,r=y.height,n=f(g.subarray(g.pos),t,r);if(e!==n){let e,o,a;switch(this.type){case i.RQf:a=n.length/4;const t=new Float32Array(4*a);for(let e=0;e<a;e++)p(n,4*e,t,4*e);e=t,o=i.RQf;break;case i.ix0:a=n.length/4;const r=new Uint16Array(4*a);for(let e=0;e<a;e++)w(n,4*e,r,4*e);e=r,o=i.ix0;break;default:console.error("THREE.RGBELoader: unsupported type: ",this.type);break}return{width:t,height:r,data:e,header:y.string,gamma:y.gamma,exposure:y.exposure,type:o}}}return null}setDataType(t){return this.type=t,this}load(t,e,r,n){function o(t,r){switch(t.type){case i.RQf:case i.ix0:t.encoding=i.tgE,t.minFilter=i.k6q,t.magFilter=i.k6q,t.generateMipmaps=!1,t.flipY=!0;break}e&&e(t,r)}return super.load(t,o,r,n)}}var u=r(10668);class h{constructor(){this.scene=(0,o.H7)(),this.camera=(0,o.Gc)(new i.Pq0(-50,50,130),75,.1,2e3),this.renderer=(0,o.Ki)(),this.controls=(0,o.ZN)(this.camera,this.renderer,!1),(0,o.AU)(this.scene,100),this.initLight(),this.initSky(),this.initMesh(),this.clock=(0,o.$i)(),this._resizeFn=this.resizeFn.bind(this),window.addEventListener("resize",this._resizeFn),this.render()}initSky(){const t=new i.Gu$(1e3,60,60),e=(new i.Tap).load("/images/textures/sky/sky.jpg"),r=new i.V9B({map:e});t.scale(1,1,-1);const n=new i.eaF(t,r);this.scene.add(n)}initMesh(){this.water=new u.E(new i.bdM(1e5,1e5),{textureWidth:512,textureHeight:512,waterNormals:(new i.Tap).load("/images/textures/waternormals.jpg",(t=>{t.wrapS=t.wrapT=i.GJx})),color:15658751,sunColor:16777215,waterColor:29439,alpha:1,distortionScale:20,fog:!1,flowDirection:new i.I9Y(1,1)}),this.water.position.y=3,this.water.rotation.x=-Math.PI/2,this.scene.add(this.water);const t=new a.B,e=new l;e.setDecoderPath("/js/draco/"),t.setDRACOLoader(e),t.load("/models/island2.glb",(t=>{const e=t.scene;this.scene.add(e)}))}initLight(){const t=new i.$p8(16777215,1);this.scene.add(t);const e=new i.ZyN(16777215,1);e.position.set(-100,100,10),this.scene.add(e);const r=new d;r.loadAsync("/hdr/050.hdr").then((t=>{t.mapping=i.wfO,this.scene.background=t,this.scene.environment=t}))}resizeFn(){this.renderer.setSize(window.innerWidth,window.innerHeight),this.camera.aspect=window.innerWidth/window.innerHeight,this.camera.updateProjectionMatrix()}render(){this.water&&(this.water.material.uniforms["time"].value+=1/60),this.renderer.render(this.scene,this.camera),this.timer=requestAnimationFrame(this.render.bind(this))}}const m={id:"webgl-output",class:"webgl-output"},f={name:"Island"};var p=Object.assign(f,{setup(t){return(0,n.sV)((()=>{new h})),(t,e)=>((0,n.uX)(),(0,n.CE)("div",m))}});const w=p;var g=w},10668:function(t,e,r){r.d(e,{E:function(){return o}});var n=r(75030);class o extends n.eaF{constructor(t,e={}){super(t),this.isWater=!0;const r=this,o=void 0!==e.textureWidth?e.textureWidth:512,i=void 0!==e.textureHeight?e.textureHeight:512,a=void 0!==e.clipBias?e.clipBias:0,s=void 0!==e.alpha?e.alpha:1,l=void 0!==e.time?e.time:0,c=void 0!==e.waterNormals?e.waterNormals:null,d=void 0!==e.sunDirection?e.sunDirection:new n.Pq0(.70707,.70707,0),u=new n.Q1f(void 0!==e.sunColor?e.sunColor:16777215),h=new n.Q1f(void 0!==e.waterColor?e.waterColor:8355711),m=void 0!==e.eye?e.eye:new n.Pq0(0,0,0),f=void 0!==e.distortionScale?e.distortionScale:20,p=void 0!==e.side?e.side:n.hB5,w=void 0!==e.fog&&e.fog,g=new n.Zcv,y=new n.Pq0,v=new n.Pq0,x=new n.Pq0,b=new n.kn4,k=new n.Pq0(0,0,-1),_=new n.IUQ,C=new n.Pq0,L=new n.Pq0,D=new n.IUQ,P=new n.kn4,T=new n.ubm,A=new n.nWS(o,i),S={uniforms:n.LlO.merge([n.fCn["fog"],n.fCn["lights"],{normalSampler:{value:null},mirrorSampler:{value:null},alpha:{value:1},time:{value:0},size:{value:1},distortionScale:{value:20},textureMatrix:{value:new n.kn4},sunColor:{value:new n.Q1f(8355711)},sunDirection:{value:new n.Pq0(.70707,.70707,0)},eye:{value:new n.Pq0},waterColor:{value:new n.Q1f(5592405)}}]),vertexShader:"\n\t\t\t\tuniform mat4 textureMatrix;\n\t\t\t\tuniform float time;\n\n\t\t\t\tvarying vec4 mirrorCoord;\n\t\t\t\tvarying vec4 worldPosition;\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <fog_pars_vertex>\n\t\t\t\t#include <shadowmap_pars_vertex>\n\t\t\t\t#include <logdepthbuf_pars_vertex>\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tmirrorCoord = modelMatrix * vec4( position, 1.0 );\n\t\t\t\t\tworldPosition = mirrorCoord.xyzw;\n\t\t\t\t\tmirrorCoord = textureMatrix * mirrorCoord;\n\t\t\t\t\tvec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t#include <beginnormal_vertex>\n\t\t\t\t#include <defaultnormal_vertex>\n\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t#include <fog_vertex>\n\t\t\t\t#include <shadowmap_vertex>\n\t\t\t}",fragmentShader:"\n\t\t\t\tuniform sampler2D mirrorSampler;\n\t\t\t\tuniform float alpha;\n\t\t\t\tuniform float time;\n\t\t\t\tuniform float size;\n\t\t\t\tuniform float distortionScale;\n\t\t\t\tuniform sampler2D normalSampler;\n\t\t\t\tuniform vec3 sunColor;\n\t\t\t\tuniform vec3 sunDirection;\n\t\t\t\tuniform vec3 eye;\n\t\t\t\tuniform vec3 waterColor;\n\n\t\t\t\tvarying vec4 mirrorCoord;\n\t\t\t\tvarying vec4 worldPosition;\n\n\t\t\t\tvec4 getNoise( vec2 uv ) {\n\t\t\t\t\tvec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);\n\t\t\t\t\tvec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );\n\t\t\t\t\tvec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );\n\t\t\t\t\tvec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );\n\t\t\t\t\tvec4 noise = texture2D( normalSampler, uv0 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv1 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv2 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv3 );\n\t\t\t\t\treturn noise * 0.5 - 1.0;\n\t\t\t\t}\n\n\t\t\t\tvoid sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {\n\t\t\t\t\tvec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );\n\t\t\t\t\tfloat direction = max( 0.0, dot( eyeDirection, reflection ) );\n\t\t\t\t\tspecularColor += pow( direction, shiny ) * sunColor * spec;\n\t\t\t\t\tdiffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;\n\t\t\t\t}\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <packing>\n\t\t\t\t#include <bsdfs>\n\t\t\t\t#include <fog_pars_fragment>\n\t\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t\t#include <lights_pars_begin>\n\t\t\t\t#include <shadowmap_pars_fragment>\n\t\t\t\t#include <shadowmask_pars_fragment>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#include <logdepthbuf_fragment>\n\t\t\t\t\tvec4 noise = getNoise( worldPosition.xz * size );\n\t\t\t\t\tvec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );\n\n\t\t\t\t\tvec3 diffuseLight = vec3(0.0);\n\t\t\t\t\tvec3 specularLight = vec3(0.0);\n\n\t\t\t\t\tvec3 worldToEye = eye-worldPosition.xyz;\n\t\t\t\t\tvec3 eyeDirection = normalize( worldToEye );\n\t\t\t\t\tsunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );\n\n\t\t\t\t\tfloat distance = length(worldToEye);\n\n\t\t\t\t\tvec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;\n\t\t\t\t\tvec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );\n\n\t\t\t\t\tfloat theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );\n\t\t\t\t\tfloat rf0 = 0.3;\n\t\t\t\t\tfloat reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );\n\t\t\t\t\tvec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;\n\t\t\t\t\tvec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);\n\t\t\t\t\tvec3 outgoingLight = albedo;\n\t\t\t\t\tgl_FragColor = vec4( outgoingLight, alpha );\n\n\t\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t\t#include <fog_fragment>\n\t\t\t\t}"},M=new n.BKk({fragmentShader:S.fragmentShader,vertexShader:S.vertexShader,uniforms:n.LlO.clone(S.uniforms),lights:!0,side:p,fog:w});M.uniforms["mirrorSampler"].value=A.texture,M.uniforms["textureMatrix"].value=P,M.uniforms["alpha"].value=s,M.uniforms["time"].value=l,M.uniforms["normalSampler"].value=c,M.uniforms["sunColor"].value=u,M.uniforms["waterColor"].value=h,M.uniforms["sunDirection"].value=d,M.uniforms["distortionScale"].value=f,M.uniforms["eye"].value=m,r.material=M,r.onBeforeRender=function(t,e,n){if(v.setFromMatrixPosition(r.matrixWorld),x.setFromMatrixPosition(n.matrixWorld),b.extractRotation(r.matrixWorld),y.set(0,0,1),y.applyMatrix4(b),C.subVectors(v,x),C.dot(y)>0)return;C.reflect(y).negate(),C.add(v),b.extractRotation(n.matrixWorld),k.set(0,0,-1),k.applyMatrix4(b),k.add(x),L.subVectors(v,k),L.reflect(y).negate(),L.add(v),T.position.copy(C),T.up.set(0,1,0),T.up.applyMatrix4(b),T.up.reflect(y),T.lookAt(L),T.far=n.far,T.updateMatrixWorld(),T.projectionMatrix.copy(n.projectionMatrix),P.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),P.multiply(T.projectionMatrix),P.multiply(T.matrixWorldInverse),g.setFromNormalAndCoplanarPoint(y,v),g.applyMatrix4(T.matrixWorldInverse),_.set(g.normal.x,g.normal.y,g.normal.z,g.constant);const o=T.projectionMatrix;D.x=(Math.sign(_.x)+o.elements[8])/o.elements[0],D.y=(Math.sign(_.y)+o.elements[9])/o.elements[5],D.z=-1,D.w=(1+o.elements[10])/o.elements[14],_.multiplyScalar(2/_.dot(D)),o.elements[2]=_.x,o.elements[6]=_.y,o.elements[10]=_.z+1-a,o.elements[14]=_.w,m.setFromMatrixPosition(n.matrixWorld);const i=t.getRenderTarget(),s=t.xr.enabled,l=t.shadowMap.autoUpdate;r.visible=!1,t.xr.enabled=!1,t.shadowMap.autoUpdate=!1,t.setRenderTarget(A),t.state.buffers.depth.setMask(!0),!1===t.autoClear&&t.clear(),t.render(e,T),r.visible=!0,t.xr.enabled=s,t.shadowMap.autoUpdate=l,t.setRenderTarget(i);const c=n.viewport;void 0!==c&&t.state.viewport(c)}}}}}]);