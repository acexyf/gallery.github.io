"use strict";(self["webpackChunkcreation_gallery"]=self["webpackChunkcreation_gallery"]||[]).push([[300],{711:function(t,e,n){n.r(e),n.d(e,{default:function(){return h}});var r=n(58258),i=n(69694),o=n(75030),a=n(24953),s=n(57399),l=n(45494),c=n(10668);class u{constructor(){this.scene=(0,i.H7)(),this.camera=(0,i.Gc)(new o.Pq0(-50,50,130),75,.1,2e3),this.renderer=(0,i.Ki)(),this.controls=(0,i.ZN)(this.camera,this.renderer,!1),(0,i.AU)(this.scene,100),this.initLight(),this.initSky(),this.initMesh(),this.clock=(0,i.$i)(),this._resizeFn=this.resizeFn.bind(this),window.addEventListener("resize",this._resizeFn),this.render()}initSky(){const t=new o.Gu$(1e3,60,60),e=(new o.Tap).load("/images/textures/sky/sky.jpg"),n=new o.V9B({map:e});t.scale(1,1,-1);const r=new o.eaF(t,n);this.scene.add(r)}initMesh(){this.water=new c.E(new o.bdM(1e5,1e5),{textureWidth:512,textureHeight:512,waterNormals:(new o.Tap).load("/images/textures/waternormals.jpg",(t=>{t.wrapS=t.wrapT=o.GJx})),color:15658751,sunColor:16777215,waterColor:29439,alpha:1,distortionScale:20,fog:!1,flowDirection:new o.I9Y(1,1)}),this.water.position.y=3,this.water.rotation.x=-Math.PI/2,this.scene.add(this.water);const t=new a.B,e=new s.Z;e.setDecoderPath("/js/draco/"),t.setDRACOLoader(e),t.load("/models/island2.glb",(t=>{const e=t.scene;this.scene.add(e)}))}initLight(){const t=new o.$p8(16777215,1);this.scene.add(t);const e=new o.ZyN(16777215,1);e.position.set(-100,100,10),this.scene.add(e);const n=new l.Y;n.loadAsync("/hdr/050.hdr").then((t=>{t.mapping=o.wfO,this.scene.background=t,this.scene.environment=t}))}resizeFn(){this.renderer.setSize(window.innerWidth,window.innerHeight),this.camera.aspect=window.innerWidth/window.innerHeight,this.camera.updateProjectionMatrix()}render(){this.water&&(this.water.material.uniforms["time"].value+=1/60),this.renderer.render(this.scene,this.camera),this.timer=requestAnimationFrame(this.render.bind(this))}}const d={id:"webgl-output",class:"webgl-output"},m={name:"Island"};var v=Object.assign(m,{setup(t){return(0,r.sV)((()=>{new u})),(t,e)=>((0,r.uX)(),(0,r.CE)("div",d))}});const f=v;var h=f},10668:function(t,e,n){n.d(e,{E:function(){return i}});var r=n(75030);class i extends r.eaF{constructor(t,e={}){super(t),this.isWater=!0;const n=this,i=void 0!==e.textureWidth?e.textureWidth:512,o=void 0!==e.textureHeight?e.textureHeight:512,a=void 0!==e.clipBias?e.clipBias:0,s=void 0!==e.alpha?e.alpha:1,l=void 0!==e.time?e.time:0,c=void 0!==e.waterNormals?e.waterNormals:null,u=void 0!==e.sunDirection?e.sunDirection:new r.Pq0(.70707,.70707,0),d=new r.Q1f(void 0!==e.sunColor?e.sunColor:16777215),m=new r.Q1f(void 0!==e.waterColor?e.waterColor:8355711),v=void 0!==e.eye?e.eye:new r.Pq0(0,0,0),f=void 0!==e.distortionScale?e.distortionScale:20,h=void 0!==e.side?e.side:r.hB5,p=void 0!==e.fog&&e.fog,w=new r.Zcv,g=new r.Pq0,x=new r.Pq0,y=new r.Pq0,C=new r.kn4,S=new r.Pq0(0,0,-1),M=new r.IUQ,_=new r.Pq0,b=new r.Pq0,P=new r.IUQ,D=new r.kn4,z=new r.ubm,k=new r.nWS(i,o),L={uniforms:r.LlO.merge([r.fCn["fog"],r.fCn["lights"],{normalSampler:{value:null},mirrorSampler:{value:null},alpha:{value:1},time:{value:0},size:{value:1},distortionScale:{value:20},textureMatrix:{value:new r.kn4},sunColor:{value:new r.Q1f(8355711)},sunDirection:{value:new r.Pq0(.70707,.70707,0)},eye:{value:new r.Pq0},waterColor:{value:new r.Q1f(5592405)}}]),vertexShader:"\n\t\t\t\tuniform mat4 textureMatrix;\n\t\t\t\tuniform float time;\n\n\t\t\t\tvarying vec4 mirrorCoord;\n\t\t\t\tvarying vec4 worldPosition;\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <fog_pars_vertex>\n\t\t\t\t#include <shadowmap_pars_vertex>\n\t\t\t\t#include <logdepthbuf_pars_vertex>\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tmirrorCoord = modelMatrix * vec4( position, 1.0 );\n\t\t\t\t\tworldPosition = mirrorCoord.xyzw;\n\t\t\t\t\tmirrorCoord = textureMatrix * mirrorCoord;\n\t\t\t\t\tvec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t#include <beginnormal_vertex>\n\t\t\t\t#include <defaultnormal_vertex>\n\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t#include <fog_vertex>\n\t\t\t\t#include <shadowmap_vertex>\n\t\t\t}",fragmentShader:"\n\t\t\t\tuniform sampler2D mirrorSampler;\n\t\t\t\tuniform float alpha;\n\t\t\t\tuniform float time;\n\t\t\t\tuniform float size;\n\t\t\t\tuniform float distortionScale;\n\t\t\t\tuniform sampler2D normalSampler;\n\t\t\t\tuniform vec3 sunColor;\n\t\t\t\tuniform vec3 sunDirection;\n\t\t\t\tuniform vec3 eye;\n\t\t\t\tuniform vec3 waterColor;\n\n\t\t\t\tvarying vec4 mirrorCoord;\n\t\t\t\tvarying vec4 worldPosition;\n\n\t\t\t\tvec4 getNoise( vec2 uv ) {\n\t\t\t\t\tvec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);\n\t\t\t\t\tvec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );\n\t\t\t\t\tvec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );\n\t\t\t\t\tvec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );\n\t\t\t\t\tvec4 noise = texture2D( normalSampler, uv0 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv1 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv2 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv3 );\n\t\t\t\t\treturn noise * 0.5 - 1.0;\n\t\t\t\t}\n\n\t\t\t\tvoid sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {\n\t\t\t\t\tvec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );\n\t\t\t\t\tfloat direction = max( 0.0, dot( eyeDirection, reflection ) );\n\t\t\t\t\tspecularColor += pow( direction, shiny ) * sunColor * spec;\n\t\t\t\t\tdiffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;\n\t\t\t\t}\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <packing>\n\t\t\t\t#include <bsdfs>\n\t\t\t\t#include <fog_pars_fragment>\n\t\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t\t#include <lights_pars_begin>\n\t\t\t\t#include <shadowmap_pars_fragment>\n\t\t\t\t#include <shadowmask_pars_fragment>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#include <logdepthbuf_fragment>\n\t\t\t\t\tvec4 noise = getNoise( worldPosition.xz * size );\n\t\t\t\t\tvec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );\n\n\t\t\t\t\tvec3 diffuseLight = vec3(0.0);\n\t\t\t\t\tvec3 specularLight = vec3(0.0);\n\n\t\t\t\t\tvec3 worldToEye = eye-worldPosition.xyz;\n\t\t\t\t\tvec3 eyeDirection = normalize( worldToEye );\n\t\t\t\t\tsunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );\n\n\t\t\t\t\tfloat distance = length(worldToEye);\n\n\t\t\t\t\tvec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;\n\t\t\t\t\tvec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );\n\n\t\t\t\t\tfloat theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );\n\t\t\t\t\tfloat rf0 = 0.3;\n\t\t\t\t\tfloat reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );\n\t\t\t\t\tvec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;\n\t\t\t\t\tvec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);\n\t\t\t\t\tvec3 outgoingLight = albedo;\n\t\t\t\t\tgl_FragColor = vec4( outgoingLight, alpha );\n\n\t\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t\t#include <fog_fragment>\n\t\t\t\t}"},N=new r.BKk({fragmentShader:L.fragmentShader,vertexShader:L.vertexShader,uniforms:r.LlO.clone(L.uniforms),lights:!0,side:h,fog:p});N.uniforms["mirrorSampler"].value=k.texture,N.uniforms["textureMatrix"].value=D,N.uniforms["alpha"].value=s,N.uniforms["time"].value=l,N.uniforms["normalSampler"].value=c,N.uniforms["sunColor"].value=d,N.uniforms["waterColor"].value=m,N.uniforms["sunDirection"].value=u,N.uniforms["distortionScale"].value=f,N.uniforms["eye"].value=v,n.material=N,n.onBeforeRender=function(t,e,r){if(x.setFromMatrixPosition(n.matrixWorld),y.setFromMatrixPosition(r.matrixWorld),C.extractRotation(n.matrixWorld),g.set(0,0,1),g.applyMatrix4(C),_.subVectors(x,y),_.dot(g)>0)return;_.reflect(g).negate(),_.add(x),C.extractRotation(r.matrixWorld),S.set(0,0,-1),S.applyMatrix4(C),S.add(y),b.subVectors(x,S),b.reflect(g).negate(),b.add(x),z.position.copy(_),z.up.set(0,1,0),z.up.applyMatrix4(C),z.up.reflect(g),z.lookAt(b),z.far=r.far,z.updateMatrixWorld(),z.projectionMatrix.copy(r.projectionMatrix),D.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),D.multiply(z.projectionMatrix),D.multiply(z.matrixWorldInverse),w.setFromNormalAndCoplanarPoint(g,x),w.applyMatrix4(z.matrixWorldInverse),M.set(w.normal.x,w.normal.y,w.normal.z,w.constant);const i=z.projectionMatrix;P.x=(Math.sign(M.x)+i.elements[8])/i.elements[0],P.y=(Math.sign(M.y)+i.elements[9])/i.elements[5],P.z=-1,P.w=(1+i.elements[10])/i.elements[14],M.multiplyScalar(2/M.dot(P)),i.elements[2]=M.x,i.elements[6]=M.y,i.elements[10]=M.z+1-a,i.elements[14]=M.w,v.setFromMatrixPosition(r.matrixWorld);const o=t.getRenderTarget(),s=t.xr.enabled,l=t.shadowMap.autoUpdate;n.visible=!1,t.xr.enabled=!1,t.shadowMap.autoUpdate=!1,t.setRenderTarget(k),t.state.buffers.depth.setMask(!0),!1===t.autoClear&&t.clear(),t.render(e,z),n.visible=!0,t.xr.enabled=s,t.shadowMap.autoUpdate=l,t.setRenderTarget(o);const c=r.viewport;void 0!==c&&t.state.viewport(c)}}}}}]);