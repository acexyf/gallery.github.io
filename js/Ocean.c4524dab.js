"use strict";(self["webpackChunkcreation_gallery"]=self["webpackChunkcreation_gallery"]||[]).push([[632],{99412:function(t,e,n){n.r(e),n.d(e,{default:function(){return h}});var i=n(4310),o=n(10185);class a extends o.Kj0{constructor(t,e={}){super(t),this.isWater=!0;const n=this,i=void 0!==e.textureWidth?e.textureWidth:512,a=void 0!==e.textureHeight?e.textureHeight:512,r=void 0!==e.clipBias?e.clipBias:0,s=void 0!==e.alpha?e.alpha:1,l=void 0!==e.time?e.time:0,c=void 0!==e.waterNormals?e.waterNormals:null,u=void 0!==e.sunDirection?e.sunDirection:new o.Pa4(.70707,.70707,0),d=new o.Ilk(void 0!==e.sunColor?e.sunColor:16777215),m=new o.Ilk(void 0!==e.waterColor?e.waterColor:8355711),h=void 0!==e.eye?e.eye:new o.Pa4(0,0,0),v=void 0!==e.distortionScale?e.distortionScale:20,f=void 0!==e.side?e.side:o.Wl3,p=void 0!==e.fog&&e.fog,g=new o.JOQ,w=new o.Pa4,y=new o.Pa4,x=new o.Pa4,S=new o.yGw,P=new o.Pa4(0,0,-1),C=new o.Ltg,b=new o.Pa4,M=new o.Pa4,_=new o.Ltg,D=new o.yGw,z=new o.cPb,E=new o.dd2(i,a),k={uniforms:o.rDY.merge([o.rBU.fog,o.rBU.lights,{normalSampler:{value:null},mirrorSampler:{value:null},alpha:{value:1},time:{value:0},size:{value:1},distortionScale:{value:20},textureMatrix:{value:new o.yGw},sunColor:{value:new o.Ilk(8355711)},sunDirection:{value:new o.Pa4(.70707,.70707,0)},eye:{value:new o.Pa4},waterColor:{value:new o.Ilk(5592405)}}]),vertexShader:"\n\t\t\t\tuniform mat4 textureMatrix;\n\t\t\t\tuniform float time;\n\n\t\t\t\tvarying vec4 mirrorCoord;\n\t\t\t\tvarying vec4 worldPosition;\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <fog_pars_vertex>\n\t\t\t\t#include <shadowmap_pars_vertex>\n\t\t\t\t#include <logdepthbuf_pars_vertex>\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tmirrorCoord = modelMatrix * vec4( position, 1.0 );\n\t\t\t\t\tworldPosition = mirrorCoord.xyzw;\n\t\t\t\t\tmirrorCoord = textureMatrix * mirrorCoord;\n\t\t\t\t\tvec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t#include <beginnormal_vertex>\n\t\t\t\t#include <defaultnormal_vertex>\n\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t#include <fog_vertex>\n\t\t\t\t#include <shadowmap_vertex>\n\t\t\t}",fragmentShader:"\n\t\t\t\tuniform sampler2D mirrorSampler;\n\t\t\t\tuniform float alpha;\n\t\t\t\tuniform float time;\n\t\t\t\tuniform float size;\n\t\t\t\tuniform float distortionScale;\n\t\t\t\tuniform sampler2D normalSampler;\n\t\t\t\tuniform vec3 sunColor;\n\t\t\t\tuniform vec3 sunDirection;\n\t\t\t\tuniform vec3 eye;\n\t\t\t\tuniform vec3 waterColor;\n\n\t\t\t\tvarying vec4 mirrorCoord;\n\t\t\t\tvarying vec4 worldPosition;\n\n\t\t\t\tvec4 getNoise( vec2 uv ) {\n\t\t\t\t\tvec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);\n\t\t\t\t\tvec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );\n\t\t\t\t\tvec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );\n\t\t\t\t\tvec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );\n\t\t\t\t\tvec4 noise = texture2D( normalSampler, uv0 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv1 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv2 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv3 );\n\t\t\t\t\treturn noise * 0.5 - 1.0;\n\t\t\t\t}\n\n\t\t\t\tvoid sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {\n\t\t\t\t\tvec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );\n\t\t\t\t\tfloat direction = max( 0.0, dot( eyeDirection, reflection ) );\n\t\t\t\t\tspecularColor += pow( direction, shiny ) * sunColor * spec;\n\t\t\t\t\tdiffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;\n\t\t\t\t}\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <packing>\n\t\t\t\t#include <bsdfs>\n\t\t\t\t#include <fog_pars_fragment>\n\t\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t\t#include <lights_pars_begin>\n\t\t\t\t#include <shadowmap_pars_fragment>\n\t\t\t\t#include <shadowmask_pars_fragment>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#include <logdepthbuf_fragment>\n\t\t\t\t\tvec4 noise = getNoise( worldPosition.xz * size );\n\t\t\t\t\tvec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );\n\n\t\t\t\t\tvec3 diffuseLight = vec3(0.0);\n\t\t\t\t\tvec3 specularLight = vec3(0.0);\n\n\t\t\t\t\tvec3 worldToEye = eye-worldPosition.xyz;\n\t\t\t\t\tvec3 eyeDirection = normalize( worldToEye );\n\t\t\t\t\tsunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );\n\n\t\t\t\t\tfloat distance = length(worldToEye);\n\n\t\t\t\t\tvec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;\n\t\t\t\t\tvec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );\n\n\t\t\t\t\tfloat theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );\n\t\t\t\t\tfloat rf0 = 0.3;\n\t\t\t\t\tfloat reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );\n\t\t\t\t\tvec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;\n\t\t\t\t\tvec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);\n\t\t\t\t\tvec3 outgoingLight = albedo;\n\t\t\t\t\tgl_FragColor = vec4( outgoingLight, alpha );\n\n\t\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t\t#include <fog_fragment>\n\t\t\t\t}"},T=new o.jyz({fragmentShader:k.fragmentShader,vertexShader:k.vertexShader,uniforms:o.rDY.clone(k.uniforms),lights:!0,side:f,fog:p});T.uniforms["mirrorSampler"].value=E.texture,T.uniforms["textureMatrix"].value=D,T.uniforms["alpha"].value=s,T.uniforms["time"].value=l,T.uniforms["normalSampler"].value=c,T.uniforms["sunColor"].value=d,T.uniforms["waterColor"].value=m,T.uniforms["sunDirection"].value=u,T.uniforms["distortionScale"].value=v,T.uniforms["eye"].value=h,n.material=T,n.onBeforeRender=function(t,e,i){if(y.setFromMatrixPosition(n.matrixWorld),x.setFromMatrixPosition(i.matrixWorld),S.extractRotation(n.matrixWorld),w.set(0,0,1),w.applyMatrix4(S),b.subVectors(y,x),b.dot(w)>0)return;b.reflect(w).negate(),b.add(y),S.extractRotation(i.matrixWorld),P.set(0,0,-1),P.applyMatrix4(S),P.add(x),M.subVectors(y,P),M.reflect(w).negate(),M.add(y),z.position.copy(b),z.up.set(0,1,0),z.up.applyMatrix4(S),z.up.reflect(w),z.lookAt(M),z.far=i.far,z.updateMatrixWorld(),z.projectionMatrix.copy(i.projectionMatrix),D.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),D.multiply(z.projectionMatrix),D.multiply(z.matrixWorldInverse),g.setFromNormalAndCoplanarPoint(w,y),g.applyMatrix4(z.matrixWorldInverse),C.set(g.normal.x,g.normal.y,g.normal.z,g.constant);const o=z.projectionMatrix;_.x=(Math.sign(C.x)+o.elements[8])/o.elements[0],_.y=(Math.sign(C.y)+o.elements[9])/o.elements[5],_.z=-1,_.w=(1+o.elements[10])/o.elements[14],C.multiplyScalar(2/C.dot(_)),o.elements[2]=C.x,o.elements[6]=C.y,o.elements[10]=C.z+1-r,o.elements[14]=C.w,h.setFromMatrixPosition(i.matrixWorld);const a=t.getRenderTarget(),s=t.xr.enabled,l=t.shadowMap.autoUpdate;n.visible=!1,t.xr.enabled=!1,t.shadowMap.autoUpdate=!1,t.setRenderTarget(E),t.state.buffers.depth.setMask(!0),!1===t.autoClear&&t.clear(),t.render(e,z),n.visible=!0,t.xr.enabled=s,t.shadowMap.autoUpdate=l,t.setRenderTarget(a);const c=i.viewport;void 0!==c&&t.state.viewport(c)}}}class r extends o.Kj0{constructor(){const t=r.SkyShader,e=new o.jyz({name:"SkyShader",fragmentShader:t.fragmentShader,vertexShader:t.vertexShader,uniforms:o.rDY.clone(t.uniforms),side:o._Li,depthWrite:!1});super(new o.DvJ(1,1,1),e),this.isSky=!0}}r.SkyShader={uniforms:{turbidity:{value:2},rayleigh:{value:1},mieCoefficient:{value:.005},mieDirectionalG:{value:.8},sunPosition:{value:new o.Pa4},up:{value:new o.Pa4(0,1,0)}},vertexShader:"\n\t\tuniform vec3 sunPosition;\n\t\tuniform float rayleigh;\n\t\tuniform float turbidity;\n\t\tuniform float mieCoefficient;\n\t\tuniform vec3 up;\n\n\t\tvarying vec3 vWorldPosition;\n\t\tvarying vec3 vSunDirection;\n\t\tvarying float vSunfade;\n\t\tvarying vec3 vBetaR;\n\t\tvarying vec3 vBetaM;\n\t\tvarying float vSunE;\n\n\t\t// constants for atmospheric scattering\n\t\tconst float e = 2.71828182845904523536028747135266249775724709369995957;\n\t\tconst float pi = 3.141592653589793238462643383279502884197169;\n\n\t\t// wavelength of used primaries, according to preetham\n\t\tconst vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );\n\t\t// this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:\n\t\t// (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))\n\t\tconst vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );\n\n\t\t// mie stuff\n\t\t// K coefficient for the primaries\n\t\tconst float v = 4.0;\n\t\tconst vec3 K = vec3( 0.686, 0.678, 0.666 );\n\t\t// MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K\n\t\tconst vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );\n\n\t\t// earth shadow hack\n\t\t// cutoffAngle = pi / 1.95;\n\t\tconst float cutoffAngle = 1.6110731556870734;\n\t\tconst float steepness = 1.5;\n\t\tconst float EE = 1000.0;\n\n\t\tfloat sunIntensity( float zenithAngleCos ) {\n\t\t\tzenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );\n\t\t\treturn EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );\n\t\t}\n\n\t\tvec3 totalMie( float T ) {\n\t\t\tfloat c = ( 0.2 * T ) * 10E-18;\n\t\t\treturn 0.434 * c * MieConst;\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\t\t\tvWorldPosition = worldPosition.xyz;\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\tgl_Position.z = gl_Position.w; // set z to camera.far\n\n\t\t\tvSunDirection = normalize( sunPosition );\n\n\t\t\tvSunE = sunIntensity( dot( vSunDirection, up ) );\n\n\t\t\tvSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );\n\n\t\t\tfloat rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );\n\n\t\t\t// extinction (absorbtion + out scattering)\n\t\t\t// rayleigh coefficients\n\t\t\tvBetaR = totalRayleigh * rayleighCoefficient;\n\n\t\t\t// mie coefficients\n\t\t\tvBetaM = totalMie( turbidity ) * mieCoefficient;\n\n\t\t}",fragmentShader:"\n\t\tvarying vec3 vWorldPosition;\n\t\tvarying vec3 vSunDirection;\n\t\tvarying float vSunfade;\n\t\tvarying vec3 vBetaR;\n\t\tvarying vec3 vBetaM;\n\t\tvarying float vSunE;\n\n\t\tuniform float mieDirectionalG;\n\t\tuniform vec3 up;\n\n\t\tconst vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );\n\n\t\t// constants for atmospheric scattering\n\t\tconst float pi = 3.141592653589793238462643383279502884197169;\n\n\t\tconst float n = 1.0003; // refractive index of air\n\t\tconst float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)\n\n\t\t// optical length at zenith for molecules\n\t\tconst float rayleighZenithLength = 8.4E3;\n\t\tconst float mieZenithLength = 1.25E3;\n\t\t// 66 arc seconds -> degrees, and the cosine of that\n\t\tconst float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;\n\n\t\t// 3.0 / ( 16.0 * pi )\n\t\tconst float THREE_OVER_SIXTEENPI = 0.05968310365946075;\n\t\t// 1.0 / ( 4.0 * pi )\n\t\tconst float ONE_OVER_FOURPI = 0.07957747154594767;\n\n\t\tfloat rayleighPhase( float cosTheta ) {\n\t\t\treturn THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );\n\t\t}\n\n\t\tfloat hgPhase( float cosTheta, float g ) {\n\t\t\tfloat g2 = pow( g, 2.0 );\n\t\t\tfloat inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );\n\t\t\treturn ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec3 direction = normalize( vWorldPosition - cameraPos );\n\n\t\t\t// optical length\n\t\t\t// cutoff angle at 90 to avoid singularity in next formula.\n\t\t\tfloat zenithAngle = acos( max( 0.0, dot( up, direction ) ) );\n\t\t\tfloat inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );\n\t\t\tfloat sR = rayleighZenithLength * inverse;\n\t\t\tfloat sM = mieZenithLength * inverse;\n\n\t\t\t// combined extinction factor\n\t\t\tvec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );\n\n\t\t\t// in scattering\n\t\t\tfloat cosTheta = dot( direction, vSunDirection );\n\n\t\t\tfloat rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );\n\t\t\tvec3 betaRTheta = vBetaR * rPhase;\n\n\t\t\tfloat mPhase = hgPhase( cosTheta, mieDirectionalG );\n\t\t\tvec3 betaMTheta = vBetaM * mPhase;\n\n\t\t\tvec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );\n\t\t\tLin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );\n\n\t\t\t// nightsky\n\t\t\tfloat theta = acos( direction.y ); // elevation --\x3e y-axis, [-pi/2, pi/2]\n\t\t\tfloat phi = atan( direction.z, direction.x ); // azimuth --\x3e x-axis [-pi/2, pi/2]\n\t\t\tvec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );\n\t\t\tvec3 L0 = vec3( 0.1 ) * Fex;\n\n\t\t\t// composition + solar disc\n\t\t\tfloat sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );\n\t\t\tL0 += ( vSunE * 19000.0 * Fex ) * sundisk;\n\n\t\t\tvec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );\n\n\t\t\tvec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );\n\n\t\t\tgl_FragColor = vec4( retColor, 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\n\t\t}"};var s=n(24919);class l{constructor(){this.scene=(0,s.lp)(),this.camera=(0,s.lE)(new o.Pa4(30,30,100),55,1,2e4),this.renderer=(0,s.I)(),this.controls=(0,s.YI)(this.camera,this.renderer,!1);const t=new o.oAp(256),e=new o._am(1,10,t);this.cubeCamera=e,this.gui=(0,s.Y2)(),this.clock=(0,s.vF)(),this.initLight(),this.initMeshes(),this.enableGui(),this._resizeFn=this.resizeFn.bind(this),window.addEventListener("resize",this._resizeFn),this.render()}initLight(){(0,s.vV)(this.scene,16777215,1);const t=new o.Ox3(16777215,1);t.color.setHSL(.1,1,.95),t.position.set(-1,1.75,1),t.position.multiplyScalar(30),this.dirLight=t,this.scene.add(t)}enableGui(){const t=this.gui.addFolder("太阳位置");t.add(this.sun,"x",-100,100).step(1).onChange(this.updateSunPosition.bind(this)),t.add(this.sun,"y",-100,100).step(1).onChange(this.updateSunPosition.bind(this)),t.add(this.sun,"z",-100,100).step(1).onChange(this.updateSunPosition.bind(this));const e=this.gui.addFolder("海水");this.waterParams={speed:1,alpha:1,distortionScale:20},e.add(this.waterParams,"speed",0,10).name("水流速度").step(.1),e.add(this.waterParams,"alpha",0,1).onChange((t=>{this.water.material.uniforms["alpha"].value=t})),e.add(this.waterParams,"distortionScale",0,240,.1).name("扭曲比例").onChange((t=>{this.water.material.uniforms["distortionScale"].value=t}));const n=this.gui.addFolder("天空");this.skyParams={turbidity:1,rayleigh:1.5},n.add(this.skyParams,"turbidity",0,100).name("浑浊度").onChange((t=>{this.sky.material.uniforms["turbidity"].value=t})),n.add(this.skyParams,"rayleigh",0,100).name("锐利值").onChange((t=>{this.sky.material.uniforms["rayleigh"].value=t}))}updateSunPosition(){this.water.material.uniforms["sunDirection"].value.copy(this.sun).normalize(),this.sky.material.uniforms["sunPosition"].value.copy(this.sun),this.renderTarget&&this.renderTarget.dispose(),this.renderTarget=this.pmremGenerator.fromScene(this.scene),this.scene.environment=this.renderTarget.texture}resizeFn(){this.renderer.setSize(window.innerWidth,window.innerHeight),this.camera.aspect=window.innerWidth/window.innerHeight,this.camera.updateProjectionMatrix()}initMeshes(){this.water=new a(new o._12(1e4,1e4),{textureWidth:512,textureHeight:512,waterNormals:(new o.dpR).load("/images/textures/waternormals.jpg",(t=>{t.wrapS=t.wrapT=o.rpg})),sunColor:16777215,waterColor:29439,alpha:1,distortionScale:20,fog:!1}),this.water.rotation.x=-Math.PI/2,this.scene.add(this.water),this.sky=new r,this.sky.scale.setScalar(1e4),this.sky.material.uniforms["turbidity"].value=1,this.sky.material.uniforms["rayleigh"].value=1.5,this.sky.material.uniforms["mieCoefficient"].value=.005,this.sky.material.uniforms["mieDirectionalG"].value=.8,this.scene.add(this.sky),this.sun=new o.Pa4(-80,5,-100),this.water.material.uniforms["sunDirection"].value.copy(this.sun).normalize(),this.sky.material.uniforms["sunPosition"].value.copy(this.sun),this.pmremGenerator=new o.anP(this.renderer),this.renderTarget&&this.renderTarget.dispose(),this.renderTarget=this.pmremGenerator.fromScene(this.scene),this.scene.environment=this.renderTarget.texture;const t=new o.Wjw(20,1),e=new o.Wid({roughness:0,side:o.ehD,flatShading:!0});this.cube=new o.Kj0(t,e),this.scene.add(this.cube)}render(){this.controls.update(this.clock.getDelta()),this.water.material.uniforms["time"].value+=this.waterParams.speed/60;const t=Date.now();this.cube.position.y=20*Math.sin(.001*t)+5,this.cube.rotation.x=.001*t*.5,this.cube.rotation.z=.001*t*.5,this.renderer.render(this.scene,this.camera),requestAnimationFrame(this.render.bind(this)),this.cubeCamera.update(this.renderer,this.scene)}beforeDestroy(){window.removeEventListener("resize",this._resizeFn)}}const c={id:"webgl-output",class:"webgl-output"},u={name:"Ocean"};var d=Object.assign(u,{setup(t){let e;return(0,i.bv)((()=>{e=new l})),(0,i.Jd)((()=>{e&&e.beforeDestroy()})),(t,e)=>((0,i.wg)(),(0,i.iD)("div",c))}});const m=d;var h=m}}]);